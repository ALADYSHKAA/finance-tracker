using System.Collections.Generic;

namespace TypeScriptDictsFromEnumsGenerator.Resources;

public static class CodeSnippets
{
    public static Dictionary<string, string> TypeScriptSnippets = new()
    {
        {
            "DeclaredTypes", @"
// tslint:disable
// eslint-disable
// ReSharper disable InconsistentNaming
//----------------------// <auto-generated>
//     Generated using custom selfmade TypeScriptDictsFromEnumsGenerator tool
// </auto-generated>
//----------------------

interface IReadOnlyDictionary<T> {
	containsKey(key: number): boolean;
	keys(): number[];
	values(): T[];
	toLookup() : IReadOnlyDictionary<T>;
}

export class ReadOnlyDictionary<T> implements IReadOnlyDictionary<T> {
	_keys: number[] = [];
	_values: T[] = [];

	constructor(init?: {key: number; value: T;} []) {
		if(!init) return;

		for(const item of init) {
			this[item.key] = item.value;
			this._keys.push(item.key);
			this._values.push(item.value);
		}
	}

	keys(): number[] {
		return this._keys;
	}

	getByKey(key:number) {
		return this._values.find(x => x[key] === key);
	}

	values(): T[] {
		return this._values;
	}

	containsKey(key: number) {
		return typeof this[key] !== 'undefined';
	} 

	toLookup() : IReadOnlyDictionary<T> {
		return this;
	}
}

export class IdTitleDescEnum {
	id: number;
	title: string;
	description?: string;
	extraData?: string;
	enumOrder?: number;

	constructor(data?: IdTitleDescEnum) {
    	if (data) {
    		for (var property in data) {
    			if (data.hasOwnProperty(property))
    				(<any>this)[property] = (<any>data)[property];
    		}
    	}
	}
}
"
        }
    };
}